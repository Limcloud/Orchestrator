function Handler($context, $inputs) {
    $vCenter  = $inputs.vCenter
    $username = $inputs.username
    $password = $inputs.password

    Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false | Out-Null

    $output = @()

    Write-Host "[INFO] Connecting to $vCenter..."
    try {
        Connect-VIServer -Server $vCenter -User $username -Password $password -Force -ErrorAction Stop | Out-Null
        Write-Host "[OK] Connected"
    }
    catch {
        return @("ERROR_CONNECT | $vCenter | $($_.Exception.Message)")
    }

    try {
        $clusters = Get-Cluster | Where-Object { $_.DrsEnabled }
        Write-Host "[INFO] DRS-enabled clusters: $($clusters.Count)"

        foreach ($cluster in $clusters) {
            Write-Host "------------------------------"
            Write-Host "[INFO] Cluster: $($cluster.Name)"

            try {
                $ccr = Get-View -Id $cluster.ExtensionData.MoRef -Property Name, ConfigurationEx

                if ($ccr -eq $null -or $ccr.ConfigurationEx -eq $null) {
                    Write-Host "[WARN] Cluster $($cluster.Name) sin ConfigurationEx, saltando..."
                    continue
                }

                # 1) Construir mapa de VM Groups
                $vmGroupMap = @{}
                foreach ($g in @($ccr.ConfigurationEx.Group)) {
                    if ($g.GetType().Name -eq "ClusterVmGroup") {
                        $set = New-Object System.Collections.Generic.HashSet[string]
                        foreach ($vmMoRef in @($g.Vm)) {
                            if ($vmMoRef -and $vmMoRef.Value) { [void]$set.Add($vmMoRef.Value) }
                        }
                        $vmGroupMap[$g.Name] = $set
                    }
                }
                Write-Host "[INFO] VM Groups (from API): $($vmGroupMap.Keys.Count)"

                # 2) Resolver reglas reales del cluster
                $covered = New-Object System.Collections.Generic.HashSet[string]
                foreach ($r in @($ccr.ConfigurationEx.Rule)) {
                    if ($r.GetType().Name -match "AffinityRuleSpec") {
                        foreach ($vmMoRef in @($r.Vm)) {
                            if ($vmMoRef -and $vmMoRef.Value) { [void]$covered.Add($vmMoRef.Value) }
                        }
                        continue
                    }
                    if ($r.GetType().Name -eq "ClusterVmHostRuleInfo") {
                        $gName = $r.VmGroupName
                        if ($gName -and $vmGroupMap.ContainsKey($gName)) {
                            foreach ($vmId in $vmGroupMap[$gName]) { [void]$covered.Add($vmId) }
                        }
                        continue
                    }
                }
                Write-Host "[INFO] VMs covered by any rule (from API): $($covered.Count)"

                # 3) Evaluar VMs del cluster
                $vms = Get-VM -Location $cluster
                Write-Host "[INFO] VMs in cluster: $($vms.Count)"

                $scanned = 0
                $without = 0

                foreach ($vm in $vms) {
                    $scanned++
                    if ($vm.Name -like "vCLS-*") { continue }
                    $vmId = $vm.ExtensionData.MoRef.Value
                    if (-not $covered.Contains($vmId)) {
                        $without++
                        $line = "$vCenter | $($cluster.Name) | $($vm.Name)"
                        $output += $line
                        Write-Host "[INFO] VM without DRS rule: $line"
                    }
                }
                Write-Host "[INFO] Cluster done: $($cluster.Name) | Scanned=$scanned | WithoutRule=$without"

            }
            catch {
                Write-Host "[WARN] Error en cluster $($cluster.Name): $($_.Exception.Message), saltando..."
                continue
            }
        }
    }
    catch {
        $output += "ERROR_RUNTIME | $vCenter | $($_.Exception.Message)"
    }
    finally {
        Disconnect-VIServer -Server $vCenter -Confirm:$false | Out-Null
        Write-Host "[INFO] Disconnected"
    }

    return $output
}
